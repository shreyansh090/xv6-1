diff a/fs.c b/fs.c	(rejected hunks)
@@ -577,12 +577,18 @@ skipelem(char *path, char *name)
 // If parent != 0, return the inode for the parent and copy the final
 // path element into name, which must have room for DIRSIZ bytes.
 static struct inode*
-_namei(char *path, int parent, char *name)
+_namei(struct inode *root, char *path, int parent, char *name, int depth)
 {
   struct inode *ip, *next;
+  char buf[100], tname[DIRSIZ];
+
+  if(depth > 5)
+    return 0;
 
   if(*path == '/')
     ip = iget(ROOTDEV, 1);
+  else if(root)
+    ip = idup(root);
   else
     ip = idup(cp->cwd);
 
@@ -598,10 +604,24 @@ _namei(char *path, int parent, char *nam
       return ip;
     }
     if((next = dirlookup(ip, name, 0)) == 0){
+      cprintf("did not find %s\n", name);
       iunlockput(ip);
       return 0;
     }
-    iunlockput(ip);
+    iunlock(ip);
+    ilock(next);
+    if(next->type == T_SYMLINK){
+      if(next->size >= sizeof(buf) || readi(next, buf, 0, next->size) != next->size){
+        iunlockput(next);
+        iput(ip);
+        return 0;
+      }
+      buf[next->size] = 0;
+      iunlockput(next);
+      next = _namei(ip, buf, 0, tname, depth+1);
+    }else
+      iunlock(next);
+    iput(ip);
     ip = next;
   }
   if(parent){
@@ -615,11 +635,11 @@ namei(char *path)
 namei(char *path)
 {
   char name[DIRSIZ];
-  return _namei(path, 0, name);
+  return _namei(0, path, 0, name, 0);
 }
 
 struct inode*
 nameiparent(char *path, char *name)
 {
-  return _namei(path, 1, name);
-}
+  return _namei(0, path, 1, name, 0);
+}
